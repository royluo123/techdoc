Key:
1,内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

2,  在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。

3, 内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话将会获得比较好的效率.

4, 内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。





C++内联函数(Inline)介绍开发者在线 Builder.com.cn 更新时间:2007-10-30作者：杜瑾 来源:yesky
本文关键词： c++ inline 内联函数 
介绍内联函数之前，有必要介绍一下预处理宏。内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如

#define TABLE_COMP(x) ((x)>0?(x):0) 
　 
就定义了一个宏。

　　为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。 

　　但是宏也有很多的不尽人意的地方。

　　1、．宏不能访问对象的私有成员。

　　2、．宏的定义很容易产生二意性。

　　我们举个例子：

#define TABLE_MULTI(x) (x*x) 

　　我们用一个数字去调用它,TABLE_MULTI(10)，这样看上去没有什么错误，结果返回100,是正确的，但是如果我们用TABLE_MULTI(10+10)去调用的话，我们期望的结果是４００，而宏的调用结果是(10+10*10+10),结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号。

#define TABLE_MULTI(x) ((x)*(x)) 

　　这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用TABLE_MULTI(a++)调用它，他们本意是希望得到(a+1)*(a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++)*(a++)，如果a的值是４，我们得到的结果是5*6=30。而我们期望的结果是5*5=25,这又出现了问题。事实上，在一些C的库函数中也有这些问题。例如: Toupper(*pChar++)就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。 

　　我们可以看到宏有一些难以避免的问题，怎么解决呢？

　　下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。

　　内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

　　我们可以用Inline来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。

　　下面我们来介绍一下内联函数的用法。

　　内联函数必须是和函数体申明在一起，才有效。像这样的申明Inline Tablefunction(int I)是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体。

Inline tablefunction(int I) {return I*I}; 

　　这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。

　　我们也可以将定义在类的外部的函数定义为内联函数，比如：

Class TableClass{
　Private:
　　Int I,j;
　Public: 
　　Int add() { return I+j;};
　　Inline int dec() { return I-j;}
　　Int GetNum();
}
inline int tableclass::GetNum(){
return I;
} 

　　上面申明的三个函数都是内联函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。

　　内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。

Class sample{
　Private:
　　Int nTest;
　Public:
　　Int readtest(){ return nTest;}
　Void settest(int I) 
} 

　　当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。


为了程序开发的目标，在头脑中牢记这些需要考虑的事项是很重要的，但是从编码期间的实用观点来看，占有支配地位的事实是：大多数调试器会与 inline 函数发生冲突。这不应该是什么重大的发现。你怎么能在一个不在那里的函数中设置断点呢？虽然一些构建环境设法支持 inline 函数的调试，多数环境还是简单地为调试构建取消了 inline 化。

　　这就导出了一个用于决定哪些函数应该被声明为 inline，哪些不应该的合乎逻辑的策略。最初，不要 inline 任何东西，或者至少要将你的 inline 化的范围限制在那些必须 inline 的和那些实在微不足道的函数上。通过慎重地使用 inline，你可以使调试器的使用变得容易，但是你也将 inline 化放在了它本来应该在的地位：作为一种手动的优化。不要忘记由经验确定的 80-20 规则，它宣称一个典型的程序用 80% 的时间执行 20% 的代码。这是一个重要的规则，因为它提醒你作为一个软件开发者的目标是识别出能全面提升你的程序性能的 20% 的代码。你可以 inline 或者用其他方式无限期地调节你的函数，但除非你将精力集中在正确的函数上，否则就是白白浪费精力。

　　Things to Remember

　　・将大部分 inline 限制在小的，调用频繁的函数上。这使得程序调试和二进制升级更加容易，最小化潜在的代码膨胀，并最大化提高程序速度的几率。

　　・不要仅仅因为函数模板出现在头文件中，就将它声明为 inline。
