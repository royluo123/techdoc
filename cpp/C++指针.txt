指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。 要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的 类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区


指针的类型

    从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：

    （1）int*ptr；//指针的类型是int*

    （2）char*ptr；//指针的类型是char*

    （3）int**ptr；//指针的类型是int**

    （4）int（*ptr）[3]；//指针的类型是int（*）[3]

    （5）int*（*ptr）[4]；//指针的类型是int*（*）[4]


指针所指向的类型

    当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

    从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

    （1）int*ptr；//指针所指向的类型是int

    （2）char*ptr；//指针所指向的的类型是char

    （3）int**ptr；//指针所指向的的类型是int*

    （4）int（*ptr）[3]；//指针所指向的的类型是int（）[3]

    （5）int*（*ptr）[4]；//指针所指向的的类型是int*（）[4]

    在指针的算术运算中，指针所指向的类型有很大的作用。

    指针的类型（即指针本身的类型）和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的\"类型\"这个概念分成\"指针的类型\"和\"指针所指向的类型\"两个概念，是精通指针的关键点之一。


指针的值，或者叫指针所指向的内存区或地址

    指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof（指针所指向的类型）的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。

    指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

    以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？


指针本身所占据的内存区

    指针本身占了多大的内存？你只要用函数sizeof（指针的类型）测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。

    指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。




指针与变量

    指针所指向的变量的生存期要不短于指针本身的生存期。

动态分配

    动态分配是指针的关键技术。它是用来在不必定义变量的情况下分配内存和让指针去指向它们。
动态分配在函数返回或执行完毕时，你分配的这块内存区域是不会被删除的。（new, malloc,calloc)


参数传递
    传递的是引用（副本）还是指针（变量本身）


指针与引用
    在前面指针的学习中，我们知道（＆）是读作“什么的地址”，但在下面的程序中，它是读作“什么的引用”

int& Number = myOtherNumber;
Number = 25; 

    引用有点像是一个指向myOtherNumber的指针，不同的是它是自动删除的。所以他比指针在某些场合更有用。与上面等价的代码是：

int* pNumber = &myOtherNumber;
*pNumber = 25; 

    指针与引用另一个不同是你不能修改你已经定义好的引用，也就是说你不能改变它在声明时所指的内容。

    引用和指针有如下三种区别：
    1 引用必须在声明时初始化，而指针不用；

    2 对于NULL不能引用，而指针可以指向NULL；

    3 引用一旦声明，引用的对象不能改变（但对象的值可以改变）；而指针可以随时改变指向的对象。

    引用能做到的，指针也可以，但指针更危险；

    （1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。

    （2）不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。

    （3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

    从上面的区别看，引用比指针安全。从编译器的角度看，引用仅仅是一个更为安全的指针。正是因为指针非常灵活，导致指针在编程时出错的可能性也很大，可以这样说指针是C++中最危险的。为了在不牺牲性能的情况下，更安全的利用指针特性，C++引入了引用。

    从上面的区别可看出，两者的区别全部表现为对指针的一个灵活特性进行限制，如初始化、合法地址、重新赋值的限制。
下面逐条给予更多的解释：

    1）2） 为确保引用对象的有效性。引用变量声明是必须初始化，却语言尽可能限制引用变量的有效性。但是注意：语言仅是尽可能保证，并不能完全保证引用时刻有效。因为编译器做不到这点。如：a） 引用对象被无意析构；常表现为返回临时变量的引用；引用变量的生存期比引用变量短； b）用于初始化引用变量的变量并未被构造，这主要是因为使用指针初始化引用变量导致，如int* p=NULL； int& temp = *p；  上面 的语句是有效的，但是引用变量是无效的。

    上面的解释说明了，引用虽然是安全的指针，但是并非绝对安全。引用使用不当，同样是致命的。根据C++标准，无效引用将产生“不确定行为”。可能是出于性能方面的考虑，标准并未提供判断引用时候有效的办法（据通过假定引用变量时刻有效，减少判断有效性的性能损失）。

    3） 引用变量的值不能改变。这个假定同样是为减少指针的误用。也就是说使用引用变量时不必担心出现同一个引用变量前后所指向的实际对象发生改变的可能。

    那什么时候使用引用呢？

    理论上，除下面两种情况外，都可以使用引用来替代指针（引用更安全）

    一是你考虑到存在不指向任何对象的可能，在这种情况下，你能够设置指针为空；

    二是你需要能够在不同的时刻指向不同的对象，在这种情况下，你能改变指针的指向。





指向数组的指针
    你也可以让指针指向一个数组，按下面的方法操作：
int *pArray;
pArray = new int[6]; 

    程序会创建一个指针pArray，让它指向一个有六个元素的数组。另外一种方法，不用动态分配：

int *pArray;
int MyArray[6];
pArray = &MyArray[0]; 

    注意，&MyArray[0] 也可以简写成 MyArray ，都表示是数组的第一个元素地址。但如果写成pArray = &MyArray可能就会出问题，结果是 pArray 指向的是指向数组的指针（在一维数组中尽管与&MyArray[0]相等），而不是你想要的，在多维数组中很容易出错。
    如果让指针指向数组元素中的下一个，可以用pArray++.也可以用你应该能想到的pArray + 1，都会让指针指向数组的下一个元素。要注意的是你在移动指针时，程序并不检查你是否已经移动地超出了你定义的数组，也就是说你很可能通过上面的简单指针加操作而访问到数组以外的数据，而结果就是，可能会使系统崩溃，所以请格外小心。

    当然有了pArray + 1，也可以有pArray － 1，这种操作在循环中很常用，特别是while循环中。

    另一个需要注意的是，如果你定义了一个指向整型数的指针：int* pNumberSet ，你可以把它当作是数组，如：pNumberSet[0] 和 *pNumberSet是相等的，pNumberSet[1]与*（pNumberSet + 1）也是相等的



指针回收
 如果你用 new 动态地分配了一个数组，
int *pArray;
pArray = new int[6]; 

    别忘了回收，
delete[] pArray; 

    这一句是告诉编译器是删除整个数组而不一个单独的元素。千万记住了。还有一点要小心，别删除一个根本就没分配内存的指针，典型的是如果没用new分配，就别用delete：

void main()
{
　　int number;
　　int *pNumber = number;
　　delete pNumber; // 错误 - *pNumber 没有用new动态分配内存.
} 
   常见问题解答Q：为什么我在编译程序时老是在 new 和 delete语句中出现'symbol undefined' 错误？
   A：new 和 delete都是C++在C上的扩展，这个错误是说编译器认为你现在的程序是C而不C++，当然会出错了。看看你的文件名是不是。cpp结尾。

   Q：new 和 malloc有什么不同？
   A：new 是C++中的关健字，用来分配内存的一个标准函数。如果没有必要，请不要在C++中使用malloc.因为malloc是C中的语法，它不是为面向对象的C++而设计的。

    Q：我可以同时使用free 和 delete吗？
    A：你应该注意的是，它们各自所匹配的操作不同。free只用在用malloc分配的内存操作中，而delete只用在用new分配的内存操作中。



指向const对象的指针和const指针 

    指向const对象的指针是一个指针，但是不能通过它来修改它所指向的对象的值。
	指向const对象的指针本身不是const类型，所以这个指针可以指向另一个const对象；
	指向const对象的指针可以被赋予一个非const对象的地址，但是不能试图通过此指针来修改该对象的值。
    声明方法： const int *p；

    const指针就是一个指针，但是它本身是const类型的。所以它初始化后不能再改变它的指向，即不能让它再指 向一个新的对象。
    声明方法：
    int* const p；             // 指向非const对象的const指针
    const int* const p；    // 指向const对象的const指针

	要弄清以上两者的区别，只要明确两点：

    1. 指针本身是const型还是非const型；

    2. 指针所指向的对象是const型还是非const型。



指针的使用
    一。什么是指针：
　
　　其实指针就像是其它变量一样，所不同的是一般的变量包含的是实际的真实的数据，而指针只是一个指示器，它告诉程序在内存的哪块区域可以找到数据。
　　这是一个非常重要的概念，有很多程序和算法都是围绕指针设计的，如链表、遍历等。
　　指针是一个数据类型，本身也需要占用四个字节的存储空间。所以用sizeof（void*）获得的值为4.
　
　　二。指针的定义
　
　　看如下的例子：
　　int *pNumber；这样就定义了int类型的指针。
　　指针变量名称以p为首字符，这是程序员通常在定义指针时的一个习惯，以提高便程序的阅读性，表示这是个指针。另外，虽然int* pNumber和int *pNumber是相同的，但是使用后一种的编程风格更好一些。比如：
　　int *pNumber1，*pNumber2；表示定义两个指针，*号和变量靠近；反之，我们可能会定义成int* pNumber1，pNumber2，这将是一个错误的定义，pNumber2就不是指针了。
　
　　三。指针的优点
　
　　a.为函数提供修改调用变元的手段；
　　b.支持C++动态分配子程序
　　c.可以改善某些子程序的效率
　　d.为动态数据结构（如二叉树、链表）提供支持
　
　　四、指针赋值及转换：
　
　　a.同类型直接赋值，异类型要进行转换。
　　b.强制转换：可以把表达式结果硬性转换为指定类型
　　c.char * p；（int *）p 把p强制转换为int型，记住转换过程中要注意两个类型的大小，大转小时可能会有数据丢失（如int到double）
　　d.涉及void *的：
　　    c 中void *类型可赋值给任何类型的指针，反之亦然
　　    c++ 中都需要强制转换
　　    void *　可看作无穷大能接纳任何类型赋值，反之不行int * p =9；void * t= p（正确）；p=t（错误）
　　e.不涉及void *的都要强制转换
　
　　五。指针和数组
　
　　不带下标的数组名返回数组的起始地址，即数组首元素的地址，所以对数组的访问可有两种方式：数组下标和指针算术。例如：
　　char* pChar；
　　char chs[100]；
　　pChar = chs；这样pChar就指向chs数组的首地址。
　
　　六。数组与引用

    a.引用只是变量的别名，而不是指向变量的指针（区别于取址运算符"&"）不占内存空间，对变量引用的改变其相应的变量也会改变。
　　b.不能对引用使用指针间接运算符“*”进行复引用操作
　　c.引用必须在声明时初始化　int &c = count；（c是count的别名）
　
　　七。指针空间的动态分配与回收
　
　　动态分配是指针的关键技术。它是用来在不必定义变量的情况下分配内存和让指针去指向它们。分配了内存，别忘了回收。你动态地分配了一个内存空间，可它绝不会被自动删除。也就是说，这块内存空间会一直存在，直到你告诉电脑你已经使用完了。可结果是，你并没有告诉电脑你已不再需要这块内存空间了，所以它会继续占据着内存空间造成浪费，甚至你的程序运行完毕，其它程序运行时它还存在。当这样的问题积累到一定程度，最终将导致系统崩溃。所以这是很重要的，在你用完它以后，请释放它的空间。
　
　　八。实际使用指针时，容易出现的错误
　
　　笔者归纳出指针错误的原因有以下几点（个人经验，欢迎大家补充）：

　　1.指针未初始化。
　　指针的初始化，不是指指针的定义，而是指针变量存储的数值是个无效的数值。比如定义float a；这个a会分配一个地址，但初始值是一个乱七八糟的数据。同样，float *a；也会为a分配一个地址，初始值也是乱七八糟的数据。初始化可以将a = NULL，这样在以后的程序中可以增加if（a == NULL）来判断指针是否有效，否则不行。或者为指针分配或者指定空间。如 float *a = new float；或者float b； float *a = &b；都可以为指针指向一块内存以实现初始化。
　
　　2.指针越界
　　指针越界是个比较难以捕捉的错误。如果测试不全面，不容易被发现。对于为指针分配的空间大小，程序员一定要时刻注意。
　
　　3.指向局部变量的指针
　　指针是记录某块内存起始地址的变量，要使指针有效，则必须确保这块内存有效。用new分配的内存空间，只要不delete，则一直有效。但是对于指向某个变量地址的指针，程序员必须清楚该变量的作用域。如果离开了变量的作用域，该变量的内存空间就会被系统自动回收，再使用指针时，将会发生错误。这是程序中最容易出现的错误。
　
　　4.指针指向的转移
　　有些初涉C++的程序员，常常会写出这样的程序：
　
　　char *pChar = new char；
　　char chs；
　　pChar = &chs；
　　delete pChar；
　
　　他们的目的是想将chs内容传递给pChar指针指向的内存。但这样写，将会使pChar先前指向的空间编程垃圾地址，因为地址无法再获取了。俗称野指针。将会导致内存泄漏。而且，在调用delete pChar时，也会发生异常错误。因为不是new的空间是不能使用delete删除的。因为pChar已经转到指向chs这个变量的地址了。
　
　　指针的艺术远不止这些，留待我们的爱好者进行深入的探讨。指针给我们的程序带来了太多的方便，同样，它也有很多难以控制的问题。如何更好的驾驭指针，可以说是C++程序员提高自己的一个手段。



